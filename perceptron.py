# -*- coding: utf-8 -*-
"""Perceptron.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1a821f49b-_snh7nHB7Crz7BBf5TuxlBq
"""



import pandas
import numpy as np

class Perceptron:
  def __init__(self,learning_rate,epochs,user_data):
    self.count = 0
    self.learning_rate = learning_rate
    self.epochs = epochs
    self.user_data = user_data
    self.i1 = user_data[0:4,0]
    self.i2 = user_data[0:4,1]
    self.outputs = user_data[0:4,2]
    self.weights = [0,0]
    print(f"Learning Rate = {self.learning_rate}\nEpochs = {self.epochs}\n i1 = {self.i1}\n i2 = {self.i2}\n output = {self.outputs} \n \n ")

  def step_function(self,y_input):
    if y_input > 1.5:
      return 1
    else:
      return 0

  def weight_update(self,input1,input2,target_output,derived_output):
    print(f"OLD WEIGHTS = {self.weights[0]} {self.weights[1]}")
    print(f"ERROR = {target_output - derived_output}")
    self.weights[0] = self.weights[0] + self.learning_rate*(target_output-self.weights[0])
    self.weights[1] = self.weights[1] + self.learning_rate*(target_output-self.weights[1])
    self.net_h1()

  def net_h1(self):
    self.count += 1
    print(f"EPOCH : {self.count}")
    if self.count > self.epochs:
      print("Epoch Out of range")
    else:
      for i in range(0,len(self.i1)):
        nh1  = self.i1[i]*self.weights[0] + self.i2[i]*self.weights[1]
        out_h1 = self.step_function(nh1)
        print(f"{self.i1[i]} {self.i2[i]} {self.outputs[i]}")
        if out_h1 == self.outputs[i]:
          pass
        else:
          self.weight_update(self.i1[i],self.i2[i],self.outputs[i],out_h1)
    self.final_outcome()

  def final_outcome(self):
    print(f"\n \nTotal epochs = {self.count}")
    print(f"W1 = {self.weights[0]} \t W2 = {self.weights[1]}")

if __name__ == "__main__":
  user_input = np.array([[1,1,1,1],
                   [1,0,0],
                   [0,1,0],
                   [0,0,0]])
  P1 = Perceptron(0.2,20,user_input)
  P1.net_h1()